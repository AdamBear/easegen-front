var C = Object.defineProperty;
var N = (r, e, t) => e in r ? C(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;
var d = (r, e, t) => N(r, typeof e != "symbol" ? e + "" : e, t);
const p = "%[a-f0-9]{2}", g = new RegExp("(" + p + ")|([^%]+?)", "gi"), F = new RegExp("(" + p + ")+", "gi");
function l(r, e) {
  try {
    return [decodeURIComponent(r.join(""))];
  } catch {
  }
  if (r.length === 1)
    return r;
  e = e || 1;
  const t = r.slice(0, e), n = r.slice(e);
  return Array.prototype.concat.call([], l(t), l(n));
}
function D(r) {
  try {
    return decodeURIComponent(r);
  } catch {
    let e = r.match(g) || [];
    for (let t = 1; t < e.length; t++)
      r = l(e, t).join(""), e = r.match(g) || [];
    return r;
  }
}
function q(r) {
  const e = {
    "%FE%FF": "��",
    "%FF%FE": "��"
  };
  let t = F.exec(r);
  for (; t; ) {
    try {
      e[t[0]] = decodeURIComponent(t[0]);
    } catch {
      const i = D(t[0]);
      i !== t[0] && (e[t[0]] = i);
    }
    t = F.exec(r);
  }
  e["%C2"] = "�";
  const n = Object.keys(e);
  for (const i of n)
    r = r.replace(new RegExp(i, "g"), e[i]);
  return r;
}
function R(r) {
  if (typeof r != "string")
    throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof r + "`");
  try {
    return decodeURIComponent(r);
  } catch {
    return q(r);
  }
}
function S(r, e) {
  if (!(typeof r == "string" && typeof e == "string"))
    throw new TypeError("Expected the arguments to be of type `string`");
  if (r === "" || e === "")
    return [];
  const t = r.indexOf(e);
  return t === -1 ? [] : [
    r.slice(0, t),
    r.slice(t + e.length)
  ];
}
function _(r, e) {
  const t = {};
  if (Array.isArray(e))
    for (const n of e) {
      const i = Object.getOwnPropertyDescriptor(r, n);
      i != null && i.enumerable && Object.defineProperty(t, n, i);
    }
  else
    for (const n of Reflect.ownKeys(r)) {
      const i = Object.getOwnPropertyDescriptor(r, n);
      if (i.enumerable) {
        const f = r[n];
        e(n, f, r) && Object.defineProperty(t, n, i);
      }
    }
  return t;
}
const H = (r) => r == null, L = (r) => encodeURIComponent(r).replaceAll(/[!'()*]/g, (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`), m = Symbol("encodeFragmentIdentifier");
function k(r) {
  switch (r.arrayFormat) {
    case "index":
      return (e) => (t, n) => {
        const i = t.length;
        return n === void 0 || r.skipNull && n === null || r.skipEmptyString && n === "" ? t : n === null ? [
          ...t,
          [s(e, r), "[", i, "]"].join("")
        ] : [
          ...t,
          [s(e, r), "[", s(i, r), "]=", s(n, r)].join("")
        ];
      };
    case "bracket":
      return (e) => (t, n) => n === void 0 || r.skipNull && n === null || r.skipEmptyString && n === "" ? t : n === null ? [
        ...t,
        [s(e, r), "[]"].join("")
      ] : [
        ...t,
        [s(e, r), "[]=", s(n, r)].join("")
      ];
    case "colon-list-separator":
      return (e) => (t, n) => n === void 0 || r.skipNull && n === null || r.skipEmptyString && n === "" ? t : n === null ? [
        ...t,
        [s(e, r), ":list="].join("")
      ] : [
        ...t,
        [s(e, r), ":list=", s(n, r)].join("")
      ];
    case "comma":
    case "separator":
    case "bracket-separator": {
      const e = r.arrayFormat === "bracket-separator" ? "[]=" : "=";
      return (t) => (n, i) => i === void 0 || r.skipNull && i === null || r.skipEmptyString && i === "" ? n : (i = i === null ? "" : i, n.length === 0 ? [[s(t, r), e, s(i, r)].join("")] : [[n, s(i, r)].join(r.arrayFormatSeparator)]);
    }
    default:
      return (e) => (t, n) => n === void 0 || r.skipNull && n === null || r.skipEmptyString && n === "" ? t : n === null ? [
        ...t,
        s(e, r)
      ] : [
        ...t,
        [s(e, r), "=", s(n, r)].join("")
      ];
  }
}
function P(r) {
  let e;
  switch (r.arrayFormat) {
    case "index":
      return (t, n, i) => {
        if (e = /\[(\d*)]$/.exec(t), t = t.replace(/\[\d*]$/, ""), !e) {
          i[t] = n;
          return;
        }
        i[t] === void 0 && (i[t] = {}), i[t][e[1]] = n;
      };
    case "bracket":
      return (t, n, i) => {
        if (e = /(\[])$/.exec(t), t = t.replace(/\[]$/, ""), !e) {
          i[t] = n;
          return;
        }
        if (i[t] === void 0) {
          i[t] = [n];
          return;
        }
        i[t] = [...i[t], n];
      };
    case "colon-list-separator":
      return (t, n, i) => {
        if (e = /(:list)$/.exec(t), t = t.replace(/:list$/, ""), !e) {
          i[t] = n;
          return;
        }
        if (i[t] === void 0) {
          i[t] = [n];
          return;
        }
        i[t] = [...i[t], n];
      };
    case "comma":
    case "separator":
      return (t, n, i) => {
        const f = typeof n == "string" && n.includes(r.arrayFormatSeparator), a = typeof n == "string" && !f && o(n, r).includes(r.arrayFormatSeparator);
        n = a ? o(n, r) : n;
        const c = f || a ? n.split(r.arrayFormatSeparator).map((U) => o(U, r)) : n === null ? n : o(n, r);
        i[t] = c;
      };
    case "bracket-separator":
      return (t, n, i) => {
        const f = /(\[])$/.test(t);
        if (t = t.replace(/\[]$/, ""), !f) {
          i[t] = n && o(n, r);
          return;
        }
        const a = n === null ? [] : n.split(r.arrayFormatSeparator).map((c) => o(c, r));
        if (i[t] === void 0) {
          i[t] = a;
          return;
        }
        i[t] = [...i[t], ...a];
      };
    default:
      return (t, n, i) => {
        if (i[t] === void 0) {
          i[t] = n;
          return;
        }
        i[t] = [...[i[t]].flat(), n];
      };
  }
}
function E(r) {
  if (typeof r != "string" || r.length !== 1)
    throw new TypeError("arrayFormatSeparator must be single character string");
}
function s(r, e) {
  return e.encode ? e.strict ? L(r) : encodeURIComponent(r) : r;
}
function o(r, e) {
  return e.decode ? R(r) : r;
}
function O(r) {
  return Array.isArray(r) ? r.sort() : typeof r == "object" ? O(Object.keys(r)).sort((e, t) => Number(e) - Number(t)).map((e) => r[e]) : r;
}
function x(r) {
  const e = r.indexOf("#");
  return e !== -1 && (r = r.slice(0, e)), r;
}
function T(r) {
  let e = "";
  const t = r.indexOf("#");
  return t !== -1 && (e = r.slice(t)), e;
}
function b(r, e) {
  return e.parseNumbers && !Number.isNaN(Number(r)) && typeof r == "string" && r.trim() !== "" ? r = Number(r) : e.parseBooleans && r !== null && (r.toLowerCase() === "true" || r.toLowerCase() === "false") && (r = r.toLowerCase() === "true"), r;
}
function y(r) {
  r = x(r);
  const e = r.indexOf("?");
  return e === -1 ? "" : r.slice(e + 1);
}
function h(r, e) {
  e = {
    decode: !0,
    sort: !0,
    arrayFormat: "none",
    arrayFormatSeparator: ",",
    parseNumbers: !1,
    parseBooleans: !1,
    ...e
  }, E(e.arrayFormatSeparator);
  const t = P(e), n = /* @__PURE__ */ Object.create(null);
  if (typeof r != "string" || (r = r.trim().replace(/^[?#&]/, ""), !r))
    return n;
  for (const i of r.split("&")) {
    if (i === "")
      continue;
    const f = e.decode ? i.replaceAll("+", " ") : i;
    let [a, c] = S(f, "=");
    a === void 0 && (a = f), c = c === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(e.arrayFormat) ? c : o(c, e), t(o(a, e), c, n);
  }
  for (const [i, f] of Object.entries(n))
    if (typeof f == "object" && f !== null)
      for (const [a, c] of Object.entries(f))
        f[a] = b(c, e);
    else
      n[i] = b(f, e);
  return e.sort === !1 ? n : (e.sort === !0 ? Object.keys(n).sort() : Object.keys(n).sort(e.sort)).reduce((i, f) => {
    const a = n[f];
    return i[f] = a && typeof a == "object" && !Array.isArray(a) ? O(a) : a, i;
  }, /* @__PURE__ */ Object.create(null));
}
function A(r, e) {
  if (!r)
    return "";
  e = {
    encode: !0,
    strict: !0,
    arrayFormat: "none",
    arrayFormatSeparator: ",",
    ...e
  }, E(e.arrayFormatSeparator);
  const t = (a) => e.skipNull && H(r[a]) || e.skipEmptyString && r[a] === "", n = k(e), i = {};
  for (const [a, c] of Object.entries(r))
    t(a) || (i[a] = c);
  const f = Object.keys(i);
  return e.sort !== !1 && f.sort(e.sort), f.map((a) => {
    const c = r[a];
    return c === void 0 ? "" : c === null ? s(a, e) : Array.isArray(c) ? c.length === 0 && e.arrayFormat === "bracket-separator" ? s(a, e) + "[]" : c.reduce(n(a), []).join("&") : s(a, e) + "=" + s(c, e);
  }).filter((a) => a.length > 0).join("&");
}
function I(r, e) {
  var i;
  e = {
    decode: !0,
    ...e
  };
  let [t, n] = S(r, "#");
  return t === void 0 && (t = r), {
    url: ((i = t == null ? void 0 : t.split("?")) == null ? void 0 : i[0]) ?? "",
    query: h(y(r), e),
    ...e && e.parseFragmentIdentifier && n ? { fragmentIdentifier: o(n, e) } : {}
  };
}
function j(r, e) {
  e = {
    encode: !0,
    strict: !0,
    [m]: !0,
    ...e
  };
  const t = x(r.url).split("?")[0] || "", n = y(r.url), i = {
    ...h(n, { sort: !1 }),
    ...r.query
  };
  let f = A(i, e);
  f && (f = `?${f}`);
  let a = T(r.url);
  if (typeof r.fragmentIdentifier == "string") {
    const c = new URL(t);
    c.hash = r.fragmentIdentifier, a = e[m] ? c.hash : `#${r.fragmentIdentifier}`;
  }
  return `${t}${f}${a}`;
}
function $(r, e, t) {
  t = {
    parseFragmentIdentifier: !0,
    [m]: !1,
    ...t
  };
  const { url: n, query: i, fragmentIdentifier: f } = I(r, t);
  return j({
    url: n,
    query: _(i, e),
    fragmentIdentifier: f
  }, t);
}
function V(r, e, t) {
  const n = Array.isArray(e) ? (i) => !e.includes(i) : (i, f) => !e(i, f);
  return $(r, n, t);
}
const B = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  exclude: V,
  extract: y,
  parse: h,
  parseUrl: I,
  pick: $,
  stringify: A,
  stringifyUrl: j
}, Symbol.toStringTag, { value: "Module" })), u = "https://docmee.cn", w = {
  dashboard: `${u}/sdk-ui/dashboard`,
  editor: `${u}/sdk-ui/editor`,
  creator: `${u}/sdk-ui/creator/0`
};
class M {
  /**
   *
   * @param {DocmeeUIConstructorOptions} options
   */
  constructor({ page: e = "dashboard", container: t, onMessage: n, ...i }) {
    d(this, "docmeeHref", w.dashboard);
    d(this, "query", { iframe: "1" });
    d(this, "iframe", null);
    if (!i.token) throw new Error("初始化时DocmeeUI时必须传入token!");
    this.docmeeHref = w[e], this.container = t, this.query = Object.assign({}, this.query, i), this.updateToken(i.token), this.iframe.addEventListener("load", () => {
      console.log("文多多AiPPT iframe 已成功挂载～"), window.addEventListener("message", async (f) => {
        if (f.source == this.iframe.contentWindow) {
          const a = f.data;
          if (a.type === "beforeGenerate" || a.type === "beforeDownload") {
            const c = await (n == null ? void 0 : n(a));
            this._postMessage({ data: c, type: `recover_${a.type}` });
          } else
            n == null || n(a);
        }
      });
    });
  }
  _postMessage(e) {
    var t, n;
    if (!this.iframe.contentWindow) throw new Error("iframe未挂载！");
    (n = (t = this.iframe) == null ? void 0 : t.contentWindow) == null || n.postMessage(e, this.docmeeHref);
  }
  // 初始化iframe
  initIframe() {
    const e = this.container, t = document.createElement("iframe"), n = location.href, i = B.stringifyUrl({
      url: this.docmeeHref,
      query: this.query,
      targetOrigin: n
    });
    t.src = i, t.style.width = "100%", t.style.height = "100%", t.style.border = "0", t.style.outline = "none", t.style.padding = "0px", this.iframe = t, e.innerHTML = "", e.appendChild(t);
  }
  /**
   * 更新用户token
   * @param {string} latestToken 新的token
   */
  updateToken(e) {
    if (!/(a|s)k_.+/.test(e)) throw new Error("token 错误！");
    this.token = e, this.query.token = e, this.initIframe();
  }
  /**
   * 卸载iframe
   */
  destroy() {
    this.container.innerHTML = "";
  }
  /**
   * 发送消息
   * @param {{type: 'warning' | 'success' | 'error' | 'info', content: string}}
   */
  sendMessage(e) {
    this._postMessage({ type: "message", data: e });
  }
  getInfo() {
    this._postMessage({ type: "getInfo" });
  }
}
window.DocmeeUI = M;
